<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
	<meta name="referrer" content="no-referrer" />
    <meta name="keywords" content="Hexo">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Hexo</title>
    <link rel="icon" type="image/png" href="/f/favicon.png">

    <link rel="stylesheet" type="text/css" href="/f/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/f/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/f/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/f/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/f/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/f/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/f/css/my.css">

    <script src="/f/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/f/" class="waves-effect waves-light">
                    
                    <img src="/f/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/f/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/f/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/f/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/f/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/f/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/f/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/f/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/f/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/f/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/f/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/f/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-08-25
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    51 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/f/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>第一章 Spring Security的概述<br>1.1、框架概述<br>Spring Security 是 Spring 家族中的一个安全管理框架，Spring Security 的两大核心功能就是认证（authentication）和授权（authorization）。</p>
<p>1.2、常用术语<br>认证 ：你是什么人。<br>授权 ：你能做什么。<br>用户 ：主要包括用户名称、用户密码和当前用户所拥有的角色信息，可用于实现认证操作。<br>角色 ：主要包括角色名称、角色描述和当前角色所拥有的权限信息，可用于实现授权操作。<br>1.3、常用单词<br>认证 ：authentication<br>授权 ：authorization<br>用户 ：user<br>角色 ：role<br>登录 ：login<br>注销 ：logout<br>1.4、环境准备<br>打开基础代码：</p>
<p>请在配套资料中，找到ssm专用基础代码，使用Idea打开ssm-security，配置好tomcat 8.5，这只是一个很普通的ssm项目，如果你有ssm项目的基础，相信你一定能看得懂，我们从左侧的菜单栏可以看到有四个部分，其中“产品管理”、“订单管理”虽然可以进行添加和查询所有，但是，这两个功能并没有和数据库交互，为了防止污染数据库表，让大家看起来很乱，所以我就使用map结构在service层进行了数据模拟；“用户管理”和“角色管理”我已经实现了最基础的增加和查询所有的功能，因为这并不是我们学习的重点，所以一些基本的配置和页面编写我就帮大家完成了。</p>
<p>我们正好趁此机会看着下边的页面，以这个项目为基础来进行学习Spring Security，最终实现的效果就是：</p>
<p>zhangsan：作为产品采购员，只能访问产品管理模块<br>lisi：作为财务管理员，只能访问订单管理模块<br>wangwu：作为系统管理员，可以访问所有模块，并可以对zhangsan和lisi进行访问权限管理</p>
<p>修改数据连接：</p>
<p>因为这个基础代码是可以在我的电脑上运行的，我安装了mysql 5.5和idea 2020.1以及tomcat 8.5，当你打开了基础项目的时候，并不一定能运行，请你检查运行环境是否和我保持一致，其中最重要的就是mysql，请最好不要安装mysql 8.0，如果你有一定的基础并且完全有能力克服此问题，你可以忽略我所说的以上这些。接下来，我们需要修改数据库的连接，这一步很重要，找到applicationContext.xml文件，根据自己的实际情况修改密码，其余的就不用动了。</p>
<!--数据库连接池-->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/test"/>
    <property name="username" value="root"/>
    <property name="password" value="密码"/>
</bean>
1
2
3
4
5
6
7
导入基础数据：

<p>请在配套资料中，找到ssm专用基础代码，将test.sql运行到自己的mysql去，为了防止破坏大家的数据库，我在这里采用公共的test数据库来进行数据保存。</p>
<p>一切准备就绪：</p>
<p>当以上所有工作都准备完成以后，意味着，你可以启动项目并进行简单的查看了，启动后在浏览器输入<a target="_blank" rel="noopener" href="http://localhost:8080/%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%88%87%E8%AE%B0%E5%9C%A8%E9%85%8D%E7%BD%AEtomcat%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E6%8A%8A%E9%82%A3%E4%B8%AA%E7%BD%91%E7%AB%99%E9%BB%98%E8%AE%A4%E7%9A%84%E5%89%8D%E7%BC%80%E5%8E%BB%E6%8E%89%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%8B%E8%BE%B9%E8%BF%99%E5%BC%A0%E5%9B%BE%E7%9A%84%E7%BA%A2%E8%89%B2%E6%A1%86%E6%A1%86%E9%83%A8%E5%88%86%E3%80%82">http://localhost:8080/进行访问，切记在配置tomcat的时候，一定要把那个网站默认的前缀去掉，也就是下边这张图的红色框框部分。</a></p>
<p>第二章 Spring Security的基本使用<br>2.1、导入所需依赖<br>Spring Security 5.4.2是基于Spring Framework 5.2.11.RELEASE构建的，但通常应与任何较新版本的Spring Framework 5.x一起使用。</p>
<!--Spring Security-->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-web</artifactId>
    <version>5.4.2</version>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-config</artifactId>
    <version>5.4.2</version>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-taglibs</artifactId>
    <version>5.4.2</version>
</dependency>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
2.2、创建配置文件
我们需要创建一个配置文件（spring-security.xml）来统一管理Spring Security的配置信息，然后将这个配置文件引入到核心配置applicationContext.xml中，以保证在启动的时候可以被Spring正常加载到。

<p>spring-security.xml：</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:security="http://www.springframework.org/schema/security"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/security
                           http://www.springframework.org/schema/security/spring-security.xsd"></p>
</beans>
1
2
3
4
5
6
7
8
9
10
applicationContext.xml：

<!--导入Spring Security配置文件-->
<import resource="spring-security.xml"/>
1
2
2.3、配置过滤器链
Spring Security是Spring采用AOP思想，基于Servlet过滤器实现的安全框架。我们可以这么理解：当客户端发送一次请求，这个请求就应该被Spring Security安全框架给拦截住，然后经过Spring Security的过滤器链的层层过滤，最终才能到达我们目标方法，只要在这其中有一个过滤器不满足，就不能到达我们的目标方法，以此起到一个安全保护的目的，下图显示了单个HTTP请求的处理程序的典型分层。



<p>那我们的Spring Security的过滤器链中的过滤器都有哪些呢？分别都起到了什么作用，我在这里以基础环境下启动为例，给大家先拿过来15个过滤器并介绍，那么，Spring Security一共就这么多过滤器吗？答案是否定的，随着spring-security.xml配置的添加，还会出现新的过滤器。那么，是不是Spring Security每次都会加载这些过滤器呢？答案也是否定的！随着spring-security.xml配置的修改，有些过滤器可能会被去掉。在这里先说，只是让大家先有个印象，而且这些过滤器见名之意并不难理解，这非常有助于我们开展接下来的工作。</p>
<p>org.springframework.security.web.context.SecurityContextPersistenceFilter<br>SecurityContextPersistenceFilter主要是使用SecurityContextRepository在session中保存或更新一个SecurityContext，并将SecurityContext给以后的过滤器使用，来为后续filter建立所需的上下文。SecurityContext中存储了当前用户的认证以及权限信息。</p>
<p>org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter<br>此过滤器用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager。</p>
<p>org.springframework.security.web.header.HeaderWriterFilter</p>
<p>向请求的Header中添加相应的信息，可在http标签内部使用security:headers来控制。</p>
<p>org.springframework.security.web.csrf.CsrfFilter</p>
<p>csrf又称跨域请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息， 如果不包含，则报错，起到防止csrf攻击的效果。</p>
<p>org.springframework.security.web.authentication.logout.LogoutFilter<br>匹配URL为/logout的请求，实现用户退出，清除认证信息。</p>
<p>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter</p>
<p>认证操作全靠这个过滤器，默认匹配URL为/login且必须为POST请求。</p>
<p>org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter</p>
<p>如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认认证页面。</p>
<p>org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter</p>
<p>如果没有在配置文件中指定退出页面，则由该过滤器生成一个默认退出页面。</p>
<p>org.springframework.security.web.authentication.<a target="_blank" rel="noopener" href="http://www.basicauthenticationfilter/">www.BasicAuthenticationFilter</a></p>
<p>此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头信息。</p>
<p>org.springframework.security.web.savedrequest.RequestCacheAwareFilter</p>
<p>通过HttpSessionRequestCache内部维护了一个RequestCache，用于缓存HttpServletRequest。</p>
<p>org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter</p>
<p>针对ServletRequest进行了一次包装，使得request具有更加丰富的API。</p>
<p>org.springframework.security.web.authentication.AnonymousAuthenticationFilter</p>
<p>当SecurityContextHolder中认证信息为空，则会创建一个匿名用户存入到SecurityContextHolder中。Spring Security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</p>
<p>org.springframework.security.web.session.SessionManagementFilter</p>
<p>SecurityContextRepository限制同一用户开启多个会话的数量。</p>
<p>org.springframework.security.web.access.ExceptionTranslationFilter</p>
<p>异常转换过滤器位于整个springSecurityFilterChain的后方，用来转换整个链路中出现的异常。</p>
<p>org.springframework.security.web.access.intercept.FilterSecurityInterceptor</p>
<p>获取所配置资源访问的授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权限。</p>
<p>我们对过滤器链有了一定的认识，接下来，我们在web.xml中配置一下过滤器链，以下这段配置，相当于过滤器链的入口，并且过滤器的名称不可随便起。</p>
<!--Spring Security过滤器链，注意过滤器名称必须叫springSecurityFilterChain-->
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
1
2
3
4
5
6
7
8
9
2.4、配置登录用户
我们要在spring-security.xml文件中配置一下，当前有哪些用户可以访问我们的权限管理系统，需要定义用户的名称、用户的密码、用户的角色。并且这三样东西都是我们自定义的，用户的名称和密码是在登录的时候需要验证的信息，当验证通过以后，就会通过角色来判断当前这个用户可以访问权限管理系统的哪些资源，默认情况下，我们是需要使用Spring Security拦截所有的请求。

<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    <!--使用Spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--><br>    &lt;security:intercept-url pattern=”/**” access=”hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”/&gt;<br></security:http></p>
<!--配置用户、密码以及所对应的角色信息，name、password、authorities中的内容都是自己定义的，{noop}代表密码不使用加密密码-->
<p><a href="security:authentication-manager">security:authentication-manager</a><br>    <a href="security:authentication-provider">security:authentication-provider</a><br>        <a href="security:user-service">security:user-service</a><br>            &lt;security:user name=”user” password=”{noop}123456” authorities=”ROLE_USER”/&gt;<br>            &lt;security:user name=”admin” password=”{noop}123456” authorities=”ROLE_ADMIN”/&gt;<br>        </security:user-service><br>    </security:authentication-provider><br></security:authentication-manager><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>如果一切正常，当你启动应用的时候，你应该会来到Spring Security的默认登录页面，这个页面是由框架自动生成的，目的就是用来进行登录的，由于这个页面中使用了bootstrap的cdn链接，第一次访问可能会很慢，以后就好很多了，不得不说其实他的这个页面设计的还是不错的，很精简的风格，如下效果：</p>
<p>2.5、开放内嵌框架<br>当你使用用户user密码123456登录的时候，默认就会进入到权限管理系统的后台首页，但是当你点击各个功能模块的时候，会发现localhost拒绝了我们的连接请求。其实这个问题还是挺常见的一个问题，项目中如果用到iframe嵌入网页，然后用到Spring Security，请求就会被拦截，如果你打开F12开发者控制台，你可能就会发现这样一句报错：Refused to display ‘<a target="_blank" rel="noopener" href="http://localhost:8080/user/add&#39;">http://localhost:8080/user/add&#39;</a> in a frame because it set ‘X-Frame-Options’ to ‘deny’.</p>
<p>Spring Security下，X-Frame-Options默认为DENY，非Spring Security环境下，X-Frame-Options的默认大多也是DENY，这种情况下，浏览器拒绝当前页面加载任何Frame页面，设置含义如下：</p>
<p>DENY：浏览器拒绝当前页面加载任何frame页面</p>
<p>SAMEORIGIN：frame页面的地址只能为同源域名下的页面</p>
<p>ALLOW-FROM：origin为允许frame加载的页面地址</p>
<p>既然清楚了问题的来源，那我们也就好解决这个问题了，有两种解决办法，第一种就是我们关掉Spring Security对frame的拦截；另外一种就是将X-Frame-Options设置为SAMEORIGIN，也就是只能是我们同域名下的请求访问，当然了，这种拦截机制肯定是为了保证系统的安全性，如果关掉了，有点太可惜了，我在这里给出两种解决方案的配置，但是我会采用第二种，而不是第一种的关闭。</p>
<p>第一种：</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    <!--使用Spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--><br>    &lt;security:intercept-url pattern=”/**” access=”hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”/&gt;<br>    <!--解决浏览器拒绝当前页面加载任何Frame页面--><br>    <a href="security:headers">security:headers</a><br>        &lt;security:frame-options disabled=”true”/&gt;<br>    </security:headers><br></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>第二种：</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    <!--使用Spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--><br>    &lt;security:intercept-url pattern=”/**” access=”hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”/&gt;<br>    <!--解决浏览器拒绝当前页面加载任何Frame页面--><br>    <a href="security:headers">security:headers</a><br>        &lt;security:frame-options policy=”SAMEORIGIN”/&gt;<br>    </security:headers><br></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>2.6、退出当前登录<br>如果想要注销，只要在浏览器地址访问：<a target="_blank" rel="noopener" href="http://localhost:8080/logout%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BA%86%E5%8A%9F%E8%83%BD%E5%AE%8C%E6%95%B4%EF%BC%8C%E8%AF%B7%E4%BD%A0%E6%89%93%E5%BC%80main.jsp%EF%BC%8C%E7%AC%AC16%E8%A1%8C%EF%BC%8C%E4%BF%AE%E6%94%B9%E6%B3%A8%E9%94%80%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BB%A5%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%EF%BC%9A">http://localhost:8080/logout就可以了，为了功能完整，请你打开main.jsp，第16行，修改注销地址为以下这段代码：</a></p>
<ul class="navbar-nav px-3">
    <li class="nav-item text-nowrap">
        <a class="btn btn-danger btn-sm" href="${pageContext.request.contextPath}/logout">注销</a>
    </li>
</ul>
1
2
3
4
5
2.7、指定登录页面
虽然默认的登录页面还不错，往往项目中的静态页面已经是前端开发好的，包括登录页面，我们想要使用自己的登录界面该怎么办？我们不妨转换一下思维，使用自带的页面，我们先打开源码，看看他是怎么写的，按照他的这个模式，我们模仿着写到自己的登录界面中不就好了，为了节约大家的时间，我就在下边贴出来了关键部分，你也可以自己打开尝试，如下所示：



<p>我们会发现，他的这个登录页面没有什么特别的，就是一个form表单，里边有两个文本框，一个是账号，一个是密码，还有最下边多了一个特殊的hidden隐藏域，这个隐藏域他是为了防止csrf跨站破坏的，这个值每一次启动项目都不一样，是一个动态值，他是为了标识当前请求一定是我们自己的请求，而不是别的网站仿造的请求，我们的所有请求都需要携带上这个标签上边的value值，我们也称这个值为token值，我们需要借助Spring Security的标签库来动态生成这个隐藏域，直接拷贝是不管用的，我照着默认登录界面自己重写了一个登录页面，放在WEB-INF/views下，名字叫login.jsp，完整的代码如下：</p>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;<br>&lt;%@ taglib prefix=”security” uri=”<a target="_blank" rel="noopener" href="http://www.springframework.org/security/tags&quot;">http://www.springframework.org/security/tags&quot;</a> %&gt;</p>
<html>
<head>
    <title>自定义登录页</title>
    <link rel="stylesheet" href="${pageContext.request.contextPath}/css/bootstrap.min.css">
    <link rel="stylesheet" href="${pageContext.request.contextPath}/css/main.css">
</head>
<body>
<div class="container mt-4">
    <form action="${pageContext.request.contextPath}/login" method="post">
        <div class="form-group">
            <label for="username">用户：</label>
            <input type="text" class="form-control" id="username" name="username" placeholder="请输入用户" required>
        </div>
        <div class="form-group">
            <label for="password">密码：</label>
            <input type="text" class="form-control" id="password" name="password" placeholder="请输入密码" required>
        </div>
        <div class="form-group form-check">
            <input type="checkbox" class="form-check-input" id="autoLogin">
            <label class="form-check-label" for="autoLogin">自动登录</label>
        </div>
        <button type="submit" class="btn btn-primary">登录</button>
        <%--隐藏域，用于防止csrf攻击--%>
        <security:csrfInput/>
    </form>
</div>
<script src="${pageContext.request.contextPath}/js/jquery-3.5.1.min.js"></script>
<script src="${pageContext.request.contextPath}/js/bootstrap.bundle.min.js"></script>
</body>
</html>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
我们编写好自己的登录页面，还得需要告诉Spring Security你登录的时候不要使用你自己的登录界面了使用我的，我们只需要在spring-security.xml

<p>中编写如下配置即可，然后重新启动项目，我们来看一看效果，是不是可以了。</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    <!--需要放行去登录界面的请求，否则你根本看不到登录页面，这段配置必须放在pattern="/**"之前，否则不能生效--><br>    &lt;security:intercept-url pattern=”/toLogin” access=”permitAll()”/&gt;<br>    <!--使用Spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--><br>    &lt;security:intercept-url pattern=”/<strong>“ access=”hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”/&gt;<br>    <!--解决浏览器拒绝当前页面加载任何Frame页面--><br>    <a href="security:headers">security:headers</a><br>        &lt;security:frame-options policy=”SAMEORIGIN”/&gt;<br>    </security:headers><br>    <!--指定自定义的认证页面--><br>    <!--
        login-page：自定义的登录页面的地址，由于login.jsp页面在WEB-INF/views下，不能直接访问，需要使用控制器方法来进行跳转
        login-processing-url：处理登录的请求，这个是固定的，这个/login地址是Spring Security内部已经规定好的
        default-target-url：登录成功以后，默认跳转到哪个界面，由于main.jsp也在WEB-INF/views下，不能直接访问，需要使用控制器方法来进行跳转
        username-parameter：登录表单中用户所对应的name的值，默认就是username，可以不用配置
        password-parameter：登录表单中密码所对应的name的值，默认就是password，可以不用配置
        authentication-failure-url：认证失败以后需要跳转的地址，这里还没有写认证错误页面，暂时出错还跳转回登录页面
    --><br>    &lt;security:form-login login-page=”/toLogin”<br>                         login-processing-url=”/login”<br>                         default-target-url=”/main”<br>                         username-parameter=”username”<br>                         password-parameter=”password”<br>                         authentication-failure-url=”/toLogin”/&gt;<br></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>@Controller<br>public class MainController {<br>    /</strong><br>     * WEB-INF/views/目录下的所有页面，默认在浏览器中不能被访问到，需要使用控制器方法跳转<br>     * 通过<a target="_blank" rel="noopener" href="http://localhost:8080/main%E6%9D%A5%E8%AE%BF%E9%97%AEWEB-INF/views/main.jsp">http://localhost:8080/main来访问WEB-INF/views/main.jsp</a><br>     * @return<br>     */<br>    @RequestMapping(“/main”)<br>    public String main() {<br>        return “main”;<br>    }</p>
<pre><code>/**
 * WEB-INF/views/目录下的所有页面，默认在浏览器中不能被访问到，需要使用控制器方法跳转
 * 通过http://localhost:8080/toLogin来访问WEB-INF/views/login.jsp
 * @return
 */
@RequestMapping(&quot;/toLogin&quot;)
public String toLogin() &#123;
    return &quot;login&quot;;
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>2.8、开放静态资源<br>最终我们启动后，发现确实来到了我们自己定义的登录页面了，说明我们之前的配置没有任何问题，但是，好像干干巴巴，啥样式都没有，这是为什么呢？如果你能看到样式，你清理一下浏览器缓存或者CTRL+F5强制刷新一下，就看不到了，至于原因，我们不难想到，刚才我们只是对跳转到登录页的请求进行了放行，而Spring Security默认是拦截所有请求，那肯定也包括静态资源css、js、img之类的，因此，静态资源是应该要被放行的，静态资源是不需要进行保护的，我们需要在spring-security.xml配置如下代码来放行静态资源。</p>
<!--直接释放无需经过SpringSecurity过滤器的静态资源-->
<!--放的位置：必须要放到<security:http auto-config="true" use-expressions="true">上边-->
<p>&lt;security:http pattern=”/css/**” security=”none”/&gt;<br>&lt;security:http pattern=”/img/**” security=”none”/&gt;<br>&lt;security:http pattern=”/js/**” security=”none”/&gt;<br>&lt;security:http pattern=”/favicon.ico” security=”none”/&gt;<br>1<br>2<br>3<br>4<br>5<br>6</p>
<p>2.9、指定退出页面<br>当你现在想要退出登录，点击右上角咱们之前配置好的注销，你就会神奇的发现，好像不能退出了，这是因为，默认退出会直接跳转到/login自动生成的认证页面，现在，认证页面也就是登录页面，已经改成我们自己的登录页面了，你只要指定了登录页面了，那默认的登录页面自然就不会创建了，因此当你退出的时候也就会报404找不到异常。</p>
<p>而我们想要解决这个问题，其实很简单，我们给退出指定一个退出页面，只需要加入以下这段配置，很类似我们配置登录页的时候的代码：</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    <!--需要放行去登录界面的请求，否则你根本看不到登录页面，这段配置必须放在pattern="/**"之前，否则不能生效--><br>    &lt;security:intercept-url pattern=”/toLogin” access=”permitAll()”/&gt;<br>    <!--使用Spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色--><br>    &lt;security:intercept-url pattern=”/**” access=”hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”/&gt;<br>    <!--解决浏览器拒绝当前页面加载任何Frame页面--><br>    <a href="security:headers">security:headers</a><br>        &lt;security:frame-options policy=”SAMEORIGIN”/&gt;<br>    </security:headers><br>    <!--指定自定义的认证页面--><br>    <!--
        login-page：自定义的登录页面的地址，由于login.jsp页面在WEB-INF/views下，不能直接访问，需要使用控制器方法来进行跳转
        login-processing-url：处理登录的请求，这个是固定的，这个/login地址是Spring Security内部已经规定好的
        default-target-url：登录成功以后，默认跳转到哪个界面，由于main.jsp也在WEB-INF/views下，不能直接访问，需要使用控制器方法来进行跳转
        username-parameter：登录表单中用户所对应的name的值，默认就是username，可以不用配置
        password-parameter：登录表单中密码所对应的name的值，默认就是password，可以不用配置
        authentication-failure-url：认证失败以后需要跳转的地址，这里还没有写认证错误页面，暂时出错还跳转回登录页面
    --><br>    &lt;security:form-login login-page=”/toLogin”<br>                         login-processing-url=”/login”<br>                         default-target-url=”/main”<br>                         username-parameter=”username”<br>                         password-parameter=”password”<br>                         authentication-failure-url=”/toLogin”/&gt;</p>
<pre><code>&lt;!--指定退出登录后跳转的页面--&gt;
&lt;!--
    logout-url：处理注销（退出）的请求，这个是固定的，这个/logout地址是Spring Security内部已经规定好的
    logout-success-url：退出成功后需要跳转的页面，我们默认跳转到登录页去
--&gt;
&lt;security:logout logout-url=&quot;/logout&quot;
                 logout-success-url=&quot;/toLogin&quot;/&gt;
</code></pre>
<p></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>即使加上了指定退出页的配置，当你登录后，点击注销，还是报404找不到资源，如果大家是跟着一步一步走来的，那就应该见过下边这个页面，当你在地址栏也好，还是a标签中也好，只要请求路径是：<a target="_blank" rel="noopener" href="http://localhost:8080/logout%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%BC%9A%E7%9C%8B%E8%A7%81%E4%B8%8B%E8%BE%B9%E8%BF%99%E4%B8%AA%E6%98%AF%E5%90%A6%E7%A1%AE%E8%AE%A4%E6%B3%A8%E9%94%80%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BD%A0%E8%BE%93%E5%85%A5%E7%9A%84%E5%88%9A%E6%89%8D%E9%82%A3%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%B9%B6%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E9%80%80%E5%87%BA%EF%BC%8C%E4%BB%96%E8%BF%98%E4%BC%9A%E9%97%AE%E4%BD%A0%E6%98%AF%E4%B8%8D%E6%98%AF%E8%A6%81%E9%80%80%E5%87%BA%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%BD%93%E4%BD%A0%E7%82%B9%E5%87%BB%E4%BA%86%E8%BF%99%E4%B8%AALog">http://localhost:8080/logout，你就会看见下边这个是否确认注销的页面，你输入的刚才那个请求并不是真正退出，他还会问你是不是要退出，只有当你点击了这个Log</a> Out，才是真正退出，你看他的源码，他是向/logout发送了一个post请求，并且还携带了csrf这个隐藏域，那我们是不是就可以仿照他这种形式，修改一下我们自己的退出功能呢。</p>
<p>第一步：找到main.jsp添加Spring Security标签库</p>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;<br>&lt;%@ taglib prefix=”security” uri=”<a target="_blank" rel="noopener" href="http://www.springframework.org/security/tags&quot;">http://www.springframework.org/security/tags&quot;</a> %&gt;<br>1<br>2<br>第二步：把之前的a标签的get请求，换成form的post请求，并加上隐藏域csrf</p>
<ul class="navbar-nav px-3">
    <li class="nav-item text-nowrap">
        <form action="${pageContext.request.contextPath}/logout" method="post">
            <security:csrfInput/>
            <input class="btn btn-danger btn-sm" type="submit" value="退出">
        </form>
    </li>
</ul>
1
2
3
4
5
6
7
8
第三章 Spring Security的高级使用
3.1、深入跨站请求伪造
3.1、CSRF的概念
CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

<p>3.2、CSRF的原理<br>假设：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，用户C为Web A网站的合法用户。</p>
<p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；<br>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；<br>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；<br>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；<br>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。<br>3.3、CSRF的防御<br>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证（Spring Security采用）；在 HTTP 头中自定义属性并验证。</p>
<p>（1）验证 HTTP Referer 字段</p>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a target="_blank" rel="noopener" href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E9%99%86">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>
<p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p>（2）在请求地址中添加 token 并验证</p>
<p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a target="_blank" rel="noopener" href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<p>在Spring Security中，“GET”, “HEAD”, “TRACE”, “OPTIONS”四类请求可以直接通过，并不会被CsrfFilter过滤器过滤，会被直接放行，但是对于其他过滤器该过滤的还是会过滤的，除去上面四类，包括POST都要被验证携带token才能通过。</p>
<p>（3）在 HTTP 头中自定义属性并验证</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<p>3.4、form表单如何添加token<br>如果您使用的是JSP，则可以使用Spring的表单标签库，只需要引入标签库，并在对应的表单添加上对应的标签即可。</p>
<p>&lt;%@ taglib prefix=”security” uri=”<a target="_blank" rel="noopener" href="http://www.springframework.org/security/tags&quot;">http://www.springframework.org/security/tags&quot;</a> %&gt;<br>1<br><a href="security:csrfInput/">security:csrfInput/</a><br>1</p>
<p>因此，当开启了 csrf 的时候，整个系统中的所有表单都需要加上 <a href="security:csrfInput/">security:csrfInput/</a> ，否则在进行表单提交的时候，会报一个 403 权限异常</p>
<p>现在你的任务就是，给系统中的所有表单都加上 <a href="security:csrfInput/">security:csrfInput/</a> ，当你完成以后，才可以进行下一小节，否则后边操作可能会出现意想不到的问题。</p>
<p>3.5、ajax请求如何添加token<br>如果您使用的是JSP，则可以使用Spring的表单标签库，只需要引入标签库，并在head标签内添加上<a href="security:csrfMetaTags/">security:csrfMetaTags/</a>标签即可。</p>
<p>&lt;%@ taglib prefix=”security” uri=”<a target="_blank" rel="noopener" href="http://www.springframework.org/security/tags&quot;">http://www.springframework.org/security/tags&quot;</a> %&gt;<br>1<br><a href="security:csrfMetaTags/">security:csrfMetaTags/</a><br>1</p>
<p>$(function () {<br>    var token = $(“meta[name=’_csrf’]”).attr(“content”);<br>    var header = $(“meta[name=’_csrf_header’]”).attr(“content”);<br>    $(document).ajaxSend(function(e, xhr, options) {<br>        xhr.setRequestHeader(header, token);<br>    });<br>});<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>3.6、文件上传避免 CSRF 拦截<br>请将MultipartFilter在Spring Security过滤器之前指定。MultipartFilter在Spring Security过滤器之前指定，这意味着任何人都可以在您的服务器上放置临时文件。但是，只有授权用户才能提交由您的应用程序所处理的文件。通常，这是推荐的方法，因为临时文件上传对大多数服务器的影响可以忽略不计。为了确保MultipartFilter在具有XML配置的Spring Security过滤器之前指定，用户可以确保的<filter-mapping>元素MultipartFilter放在web.xml中的springSecurityFilterChain之前，如下所示：</p>
<filter>
    <filter-name>MultipartFilter</filter-name>
    <filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>
</filter>
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>MultipartFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
3.7、如何关闭 CSRF 防御机制
<security:http auto-config="true" use-expressions="true">
    ...
    ...
    <!--禁用csrf防护机制-->
    <security:csrf disabled="true"/>
</security:http>
1
2
3
4
5
6
3.2、完成网站自动登录
如果我想要关闭浏览器，下次再打开浏览器，权限管理系统会自动根据我上次的登录状态进行登录，这就是登录常用的“自动登录功能”，要想实现自动登录功能，我们需要实现两处关键配置就能使用了，具体操作如下：

<p>打开 login.jsp 修改自动登录的name为remember-me，这是一个默认名称，可以修改，但是一般我们就叫这个名</p>
<div class="form-group form-check">
    <input type="checkbox" class="form-check-input" id="autoLogin" name="remember-me">
    <label class="form-check-label" for="autoLogin">自动登录</label>
</div>
1
2
3
4
打开 spring-security.xml 开启自动登录功能

<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    …<br>    …<br>    <!--开启remember-me过滤器--><br>    <!--
        remember-me-parameter：指定自动登录表单的name的值，默认是remember-me，可取值有：true、on、yes、1，一般用true
        token-validity-seconds：设置token存储时间为3600秒，也就是1个小时后会失效
    --><br>    &lt;security:remember-me<br>            remember-me-parameter=”remember-me”<br>            token-validity-seconds=”3600”/&gt;<br></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>打开 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，登录以后，我们在关闭浏览器，然后重新打开 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a> ，发现仍然可以访问，并且这时候不需要登录，他是怎么做到的呢？其实，在登录成功以后会往当前网站的cookie中写入一个自动登录的token值，当我们下次启动的时候，只要这个cookie没有消失，Spring Security就能拿到这个cookie的中保存的token的值，然后帮我们自动登录认证。</p>
<p>3.3、保存凭据到数据库<br>自动登录功能方便是大家看得见的，但是安全性却令人担忧。因为cookie毕竟是保存在客户端的，很容易盗取，而且 cookie的值还与用户名、密码这些敏感数据相关，虽然加密了，但是将敏感信息存在客户端，还是不太安全。那么这就要提醒喜欢使用此功能的，用完网站要及时手动退出登录，清空认证信息。 此外，Spring Security还提供了remember-me的另一种相对更安全的实现机制：在客户端的cookie中，仅保存一个无意义的加密串（与用户名、密码等敏感数据无关），然后在数据库中保存该加密串-用户信息的对应关系，自动登录时，用cookie中的加密串，到数据库表中验证，如果通过，自动登录才算通过。这样，自动登录功能的安全性就有了保证，因此，我们需要在数据库中创建一张用于保存自动登录信息的表，这张表是固定的，包括名称、字段等信息，都不能修改，否则会认识失败。</p>
<p>CREATE TABLE <code>persistent_logins</code> (<br><code>username</code> varchar(64) NOT NULL,<br><code>series</code> varchar(64) NOT NULL,<br><code>token</code> varchar(64) NOT NULL,<br><code>last_used</code> timestamp NOT NULL,<br>PRIMARY KEY (<code>series</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>接下来，我们需要配置一下，告诉Spring Security使用哪一个dataSource来操作这个表</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    …<br>    …<br>    <!--开启remember-me过滤器--><br>    <!--
        data-source-ref="dataSource"：指定数据库连接池
        remember-me-parameter：指定自动登录表单的name的值，默认是remember-me，可取值有：true、on、yes、1，一般用true
        token-validity-seconds：设置token存储时间为3600秒，也就是1个小时后会失效
    --><br>    &lt;security:remember-me<br>            data-source-ref=”dataSource”<br>            remember-me-parameter=”remember-me”<br>            token-validity-seconds=”3600”/&gt;<br></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>接下来，我们重新进行测试，发现也是可行的，并且这里给出了浏览器和数据库的截图信息：</p>
<p>3.4、展示当前登录用户<br>登录成功以后，如何显示出来当前登录成功的用户名呢？我们这里给出两种常用方法，他们都必须使用Spring Security的标签库，具体代码如下：</p>
<p>第一种：打开 main.jsp 修改第13行</p>
<span class="hidden-xs">
    <security:authentication property="principal.username" />
</span>
1
2
3
第二种：打开 main.jsp 修改第13行

<span class="hidden-xs">
    <security:authentication property="name" />
</span>
1
2
3
使用第一种方法修改完成后，代码如下：

<a class="navbar-brand col-md-3 col-lg-2 mr-0 px-3" href="#">
    权限管理系统，欢迎：
    <span class="hidden-xs">
        <security:authentication property="principal.username" />
    </span>
</a>
1
2
3
4
5
6


<p>3.5、对接数据库中数据<br>我们现在已经在 spring-security.xml 写死并配置好了两个用户（user、admin）以及他们所对应的角色，但是，在真实的企业开发中，这些信息显然是不能保存在配置文件中的，因为要动态添加删除用户以及角色，我们就需要使用数据库来保存，现在 Spring Security 默认是走的配置文件中的账户和密码，我们如何对接数据库中的数据呢？</p>
<p>第一步：实现自己的 SysUserDetailsService 接口继承 UserDetailsService</p>
<p>public interface SysUserDetailsService extends UserDetailsService {</p>
<p>}<br>1<br>2<br>3<br>第二步：实现自己的 SysUserDetailsService 接口的 loadUserByUsername 方法，方法传入一个字符串，代表当前登录的用户名</p>
<p>@Service<br>@Transactional<br>public class SysUserDetailsServiceImpl implements SysUserDetailsService {<br>    @Autowired<br>    private SysUserMapper sysUserMapper;</p>
<pre><code>@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
    //根据用户名去数据库中查询指定用户，这就要保证数据库中的用户的名称必须唯一，否则将会报错
    SysUser sysUser = sysUserMapper.findUserByUsername(username);
    //如果没有查询到这个用户，说明数据库中不存在此用户，认证失败，返回null
    if (sysUser == null) &#123;
        return null;
    &#125;

    //获取该用户所对应的所有角色，当查询用户的时候级联查询其所关联的所有角色，用户与角色是多对多关系
    //如果这个用户没有所对应的角色，也就是一个空集合，那么在登录的时候会报 403 没有权限异常，切记这点
    List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();
    List&lt;SysRole&gt; sysRoles = sysUser.getSysRoles();
    for (SysRole sysRole : sysRoles) &#123;
        authorities.add(new SimpleGrantedAuthority(sysRole.getName()));
    &#125;

    //最终需要返回一个SpringSecurity的UserDetails对象，&#123;noop&#125;表示不加密认证
    //org.springframework.security.core.userdetails.User实现了UserDetails对象，是SpringSecurity内置认证对象
    return new User(sysUser.getUsername(), &quot;&#123;noop&#125;&quot;+sysUser.getPassword(), authorities);
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>第三步：修改配置文件 spring-security.xml 中的认证提供者换成咱们自己定义的，然后重新启动系统使用数据库中的账户登录即可。</p>
<!--配置用户、密码以及所对应的角色信息，name、password、authorities中的内容都是自己定义的，{noop}代表密码不使用加密密码-->
<p><a href="security:authentication-manager">security:authentication-manager</a><br>    &lt;security:authentication-provider user-service-ref=”sysUserDetailsServiceImpl”&gt;<br>        <!--<security:user-service>--><br>            <!--<security:user name="user" password="{noop}123456" authorities="ROLE_USER"/>--><br>            <!--<security:user name="admin" password="{noop}123456" authorities="ROLE_ADMIN"/>--><br>        <!--</security:user-service>--><br>    </security:authentication-provider><br></security:authentication-manager><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>第四步：使用数据库所提供的账户进行登录测试。</p>
<p>3.6、用户密码进行加密<br>第一步：配置加密对象</p>
<!--加密对象-->
<bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>

<!--配置用户、密码以及所对应的角色信息，name、password、authorities中的内容都是自己定义的，{noop}代表密码不使用加密密码-->
<p><a href="security:authentication-manager">security:authentication-manager</a><br>    &lt;security:authentication-provider user-service-ref=”sysUserDetailsServiceImpl”&gt;<br>        <!--<security:user-service>--><br>            <!--<security:user name="user" password="{noop}123456" authorities="ROLE_USER"/>--><br>            <!--<security:user name="admin" password="{noop}123456" authorities="ROLE_ADMIN"/>--><br>        <!--</security:user-service>--><br>        <!--指定认证使用的加密对象，如果加密对象的id=passwordEncoder，下边这句你都可以不用配置，默认引用就是passwordEncoder--><br>        &lt;security:password-encoder ref=”passwordEncoder”/&gt;<br>    </security:authentication-provider><br></security:authentication-manager><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>第二步：保存用户的时候，给用户的密码进行加密，修改SysUserServiceImpl</p>
<p>@Autowired<br>private BCryptPasswordEncoder passwordEncoder;</p>
<p>@Override<br>public void save(SysUser sysUser) {<br>    sysUser.setPassword(passwordEncoder.encode(sysUser.getPassword()));<br>    sysUserMapper.save(sysUser);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>第三步：去掉 SysUserDetailsServiceImpl 中的{noop}</p>
<p>@Override<br>public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {<br>    …<br>    …<br>    //最终需要返回一个SpringSecurity的UserDetails对象，{noop}表示不加密认证<br>    //org.springframework.security.core.userdetails.User实现了UserDetails对象，是SpringSecurity内置认证对象<br>    return new User(sysUser.getUsername(), sysUser.getPassword(), authorities);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>第四步：手动修改数据库中的密码为加密后的密码，我们现在需要知道123456加密后的密文，需要手动生成，注意啊，每一次生成都不一样，但是都可以用</p>
<p>public class CreatePwd {<br>    public static void main(String[] args) {<br>        BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();<br>        String encode = bCryptPasswordEncoder.encode(“123456”);<br>        System.out.println(encode);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>第五步：重新启动权限管理系统，分别使用zhangsan、lisi、wangwu进行登录测试，发现都可以正常进行登录，我在创建表的时候默认就给他们分配了权限。</p>
<p>zhangsan：用户权限和产品权限</p>
<p>lisi：用户权限和订单权限</p>
<p>wangwu：所有权限</p>
<p>为什么这三个账户都能登录成功，以下几个方面很重要：</p>
<p>Spring Security已经配置了加密登录，我们手动把数据库中的123456改成了密文，登录的时候才可以保证认证成功</p>
<p>认证成功了可不一定能访问我们系统的资源，必须拥有相对应的角色，虽然角色是我们自己定义的，但是请你不要忘记，我们一开始，使用死的配置进行配置用户的时候，那个时候，只有拥有ROLE_USER和ROLE_ADMIN这样的用户才能访问系统资源，这就是为什么zhangsan和lisi必须要有ROLE_USER角色了</p>
<!--使用Spring的el表达式来指定项目所有资源访问都必须有ROLE_USER或ROLE_ADMIN角色-->
<p>&lt;security:intercept-url pattern=”/**” access=”hasAnyRole(‘ROLE_USER’,’ROLE_ADMIN’)”/&gt;<br>1<br>2<br>3.7、动态展示功能菜单<br>3.7.1、页面菜单动态展示<br>细心的你应该发现了，无论是zhangsan、lisi、wangwu中的哪一个人登录进去，左侧的菜单都是下边这个样子，完全没有实现我们的效果</p>
<p>我们可以使用Spring Security提供的标签库来动态判断，只有拥有指定角色的人，才可以访问我们指定的功能模块，具体做法如下，找到main.jsp进行修改：</p>
<ul class="nav flex-column">
    <security:authorize access="hasAnyRole('ROLE_ADMIN','ROLE_PRODUCT')">
        <li class="nav-item border-bottom">
            <p><a href="#">产品管理</a></p>
            <ul>
                <li><a href="/product/add" target="container">添加产品</a></li>
                <li><a href="/product/findAll" target="container">产品列表</a></li>
            </ul>
        </li>
    </security:authorize>

<pre><code>&lt;security:authorize access=&quot;hasAnyRole(&#39;ROLE_ADMIN&#39;,&#39;ROLE_ORDER&#39;)&quot;&gt;
    &lt;li class=&quot;nav-item border-bottom&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;#&quot;&gt;订单管理&lt;/a&gt;&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/order/add&quot; target=&quot;container&quot;&gt;添加订单&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/order/findAll&quot; target=&quot;container&quot;&gt;订单列表&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/security:authorize&gt;

&lt;%--只有拥有系统管理员角色的用户才能够添加用户、修改角色--%&gt;
&lt;security:authorize access=&quot;hasAnyRole(&#39;ROLE_ADMIN&#39;)&quot;&gt;
    &lt;li class=&quot;nav-item border-bottom&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;#&quot;&gt;用户管理&lt;/a&gt;&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/user/add&quot; target=&quot;container&quot;&gt;添加用户&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/user/findAll&quot; target=&quot;container&quot;&gt;用户列表&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li class=&quot;nav-item border-bottom&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;#&quot;&gt;角色管理&lt;/a&gt;&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/role/add&quot; target=&quot;container&quot;&gt;添加角色&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/role/findAll&quot; target=&quot;container&quot;&gt;角色列表&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/security:authorize&gt;
</code></pre>
</ul>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
我们保存以后，重新启动权限管理系统，再次分别登录zhangsan、lisi、wangwu，看看左侧菜单栏发生了什么变化

<p>zhangsan：</p>
<p>lisi：</p>
<p>wangwu：</p>
<p>3.7.2、业务代码动态拦截<br>我们发现虽然界面上效果好像可以了，但是，难道就真的可以了吗？还有没有什么纰漏，我们假设一种场景，一个程序员，它使用zhangsan的账户登录系统后，闲来无事，他呢，自己又懂技术，想试试，在地址栏直接输入李四的订单页面，看看能不能进去，结果发现，进去了，这就是纰漏。</p>
<p>我们上一步所实现的只是表面你所看到的，也就是视图上实现了不同用户可以看到不同的菜单，但是在控制器层并没有拦截住，这就是导致问题的根本原因，一般我们的解决办法就是在业务层（控制器层也可以，但是不推荐），给相对应的方法或者相应的类添加角色判断注解，只有拥有相应角色的用户才能访问该方法或者该类，在Spring Security中，一共支持三种注解都可以做到这个效果，而这三种注解的开启都是一个标签上进行开启，我接下来会把三个注解都打开，只使用第一种注解，其余两种会给大家注释掉，要记住，打开的哪个注解，就用哪个注解来限制访问，必须配套使用。这里演示三类注解，实际开发中，用一类即可！</p>
<p>在 spring-security.xml 添加以下配置</p>
<!--
开启权限控制注解支持，以下三个配置只用开启一个就行了，全部开启也不会报错
    jsr250-annotations="enabled"表示支持jsr250-api的注解，需要jsr250-api的jar包
    pre-post-annotations="enabled"表示支持spring表达式注解
    secured-annotations="enabled"这才是SpringSecurity提供的注解
-->
<p>&lt;security:global-method-security jsr250-annotations=”enabled”<br>                                 pre-post-annotations=”enabled”<br>                                 secured-annotations=”enabled”/&gt;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>修改OrderServiceImpl：我们就以这个类为例进行讲解，其余剩下的所有的实现都需要标注，可以在方法上标注注解，也可以在类上标注注解</p>
<p>@RolesAllowed({“ROLE_ADMIN”, “ROLE_ORDER”})//JSR-250注解<br>//@PreAuthorize(“hasAnyRole(‘ROLE_ADMIN’,’ROLE_ORDER’)”)//spring表达式注解<br>//@Secured({“ROLE_ADMIN”,”ROLE_ORDER”})//SpringSecurity注解<br>@Override<br>public void save(Order Order) {<br>    int size = orderMap.size();<br>    int id = ++size;<br>    Order.setId(id);<br>    orderMap.put(id, Order);<br>}</p>
<p>@RolesAllowed({“ROLE_ADMIN”, “ROLE_ORDER”})//JSR-250注解<br>//@PreAuthorize(“hasAnyRole(‘ROLE_ADMIN’,’ROLE_ORDER’)”)//spring表达式注解<br>//@Secured({“ROLE_ADMIN”,”ROLE_ORDER”})//SpringSecurity注解<br>@Override<br>public List<Order> findAll() {<br>    Collection<Order> Orders = orderMap.values();<br>    return new ArrayList&lt;&gt;(Orders);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>完成以后，重新启动权限管理系统，然后登录zhangsan，你再次输入lisi的添加订单地址，看看还能不能访问，你会发现，添加订单界面还在，但是当你点击提交挺订单的时候，就会 403 权限不足，如果你连界面都不想展示出来，请你在控制层上标注相对应的注解即可。</p>
<p>需要注意的是，如果添加到服务层，那相应的开启配置自然是配置到spring-security.xml，如果是添加到控制器层，那相应的开启配置需要添加到spring-mvc.xml中，这一点也一定要切记。</p>
<p>3.8、权限不足异常处理<br>大家也发现了，每次权限不足都出现403页面，这个错误页面是tomcat自己生成的，非常的难看，很不友好，当出现403异常以后，如何跳转到我们自定义的页面，接下来，我将提供三种形式来解决，第一种是tomcat提供的解决方式，第二种是Spring Security提供的解决方式，第三种是Spring MVC提供的解决方式，在解决问题之前，我们先定义自己的403没有权限的页面，以及通过控制器方法跳转到403.jsp，以上这几种情况还可以配置404、500等错误页面的跳转，如有需要也可以自行配置。</p>
<p>在 views 目录中创建 error 目录，在 error 目录中创建 403.jsp</p>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p>
<html>
<head>
    <title>没有权限</title>
</head>
<body>
<h3>403，没有权限</h3>
</body>
</html>
1
2
3
4
5
6
7
8
9
在 MainController 中添加跳转方法，代码如下：

<p>@RequestMapping(“/to403”)<br>public String to403() {<br>    return “error/403”;<br>}<br>1<br>2<br>3<br>4<br>以下几种方法任选其一使用即可，不必全部配置，推荐使用第三种Spring MVC提供的异常处理机制。</p>
<p>第一种： 在 web.xml 中配置以下代码即可</p>
<error-page>
    <error-code>403</error-code>
    <location>/to403</location>
</error-page>
1
2
3
4


<p>第二种： 在 spring-security.xml中配置一下代码即可</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    …<br>    …<br>    <!--403异常处理--><br>    &lt;security:access-denied-handler error-page=”/to403”/&gt;<br></security:http><br>1<br>2<br>3<br>4<br>5<br>6</p>
<p>第三种： 在 com.caochenlei.controller 中创建一个包 advice ，然后创建 ExceptionAdvice</p>
<p>@ControllerAdvice<br>public class ExceptionAdvice {<br>    //别导错类了：org.springframework.security.access.AccessDeniedException<br>    //只有出现AccessDeniedException异常才调转403.jsp页面<br>    @ExceptionHandler(AccessDeniedException.class)<br>    public String exceptionAdvice() {<br>        return “forward:/to403”;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>3.9、保证当前登录人数<br>有时候我们为了安全，也可以设置同一个账户，只能同时有一个人在线，我们只需要简单的配置就能实现。</p>
<p>第一种：同一个账户，只能有一个人访问，这个账户登录之后，如果不退出，此账户在其他地方均不可登录。</p>
<p>&lt;security:http auto-config=”true” use-expressions=”true”&gt;<br>    …<br>    …<br>    <a href="security:session-management">security:session-management</a><br>        <!--
             max-sessions：最大会话数是1，也就是一个账户最多只能允许一个人登录
             error-if-maximum-exceeded：属性为true的话，如果帐号已经登录，在其它地方这个帐号就登录不了了
         --><br>        &lt;security:concurrency-control max-sessions=”1” error-if-maximum-exceeded=”true”/&gt;<br>    </security:session-management><br></security:http><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>第二种：同一个账户，只能有一个人访问，这个账户登录之后，如果不退出，此账户在其他地方登录，均被提示不能登录并跳转</p>
<p>expired.jsp</p>
<p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p>
<html>
<head>
    <title>温馨提示</title>
</head>
<body>
<h2>账户已经在别的地方登录</h2>
<h2><a href="/toLogin">是否继续登录</a></h2>
</body>
</html>
1
2
3
4
5
6
7
8
9
10
MainController

<p>@RequestMapping(“/toExpired”)<br>public String toExpired() {<br>    return “expired”;<br>}<br>1<br>2<br>3<br>4<br>spring-security.xml</p>
<!--
    会话管理器
        invalid-session-url：必须要有的属性，否则不会踢掉原来的登录，被踢掉的用户再发出请求会转到/toExpired页面
-->
<pre><code>&lt;security:session-management invalid-session-url=&quot;/toExpired&quot;&gt;
    &lt;!--
</code></pre>
<p>max-sessions：最大会话数是1，也就是一个账户最多只能允许一个人登录<br>error-if-maximum-exceeded：属性默认是false，表示同一账号，先登录的，会被后登录者强制下线，为true时，表示一旦有用户登录，其他用户将无法登录<br>expired-url：不设置的话会提示：This session has been expired (possibly due to multiple concurrent logins being attempted as the same user).<br>expired-url：设置的话就会跳转到哪个页面<br>        –&gt;<br>        &lt;security:concurrency-control max-sessions=”1” error-if-maximum-exceeded=”false” expired-url=”/toExpired”/&gt;<br>    </security:session-management><br></security:http><br>————————————————<br>版权声明：本文为CSDN博主「轻松的小希」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38490457/article/details/112756284">https://blog.csdn.net/qq_38490457/article/details/112756284</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jnzisnoone/article/details/105546460">https://blog.csdn.net/jnzisnoone/article/details/105546460</a></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security
    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;security&#x2F;spring-security.xsd&quot;&gt;
 
    &lt;!-- 配置不拦截的资源 --&gt;
    &lt;security:http pattern&#x3D;&quot;&#x2F;login.jsp&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;
    &lt;security:http pattern&#x3D;&quot;&#x2F;failer.jsp&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;
    &lt;security:http pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;
    &lt;security:http pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;
    &lt;security:http pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;
 
    &lt;!--
    	配置具体的规则
    	auto-config&#x3D;&quot;true&quot;	不用自己编写登录的页面，框架提供默认登录页面
    	use-expressions&#x3D;&quot;false&quot;	是否使用SPEL表达式（没学习过）
    --&gt;
    &lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;false&quot;&gt;
        &lt;!-- 配置具体的拦截的规则 pattern&#x3D;&quot;请求路径的规则&quot; access&#x3D;&quot;访问系统的人，必须有ROLE_USER的角色&quot; --&gt;
        &lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;
 
        &lt;!-- 定义跳转的具体的页面 --&gt;
        &lt;security:form-login
                login-page&#x3D;&quot;&#x2F;login.jsp&quot;
                login-processing-url&#x3D;&quot;&#x2F;login.do&quot;
                default-target-url&#x3D;&quot;&#x2F;index.jsp&quot;
                authentication-failure-url&#x3D;&quot;&#x2F;failer.jsp&quot;
                authentication-success-forward-url&#x3D;&quot;&#x2F;pages&#x2F;main.jsp&quot;
        &#x2F;&gt;
 
        &lt;!-- 关闭跨域请求 --&gt;
        &lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;
 
        &lt;!-- 退出 --&gt;
        &lt;security:logout invalidate-session&#x3D;&quot;true&quot; logout-url&#x3D;&quot;&#x2F;logout.do&quot; logout-success-url&#x3D;&quot;&#x2F;login.jsp&quot; &#x2F;&gt;
 
    &lt;&#x2F;security:http&gt;
 
    &lt;!-- 切换成数据库中的用户名和密码 --&gt;
    &lt;security:authentication-manager&gt;
        &lt;security:authentication-provider user-service-ref&#x3D;&quot;userService&quot;&gt;
    &lt;!--
                &lt;security:password-encoder ref&#x3D;&quot;passwordEncoder&quot;&#x2F;&gt;
    --&gt;
            &lt;&#x2F;security:authentication-provider&gt;
        &lt;&#x2F;security:authentication-manager&gt;
 
        &lt;!-- 配置加密类 --&gt;
    &lt;bean id&#x3D;&quot;passwordEncoder&quot; class&#x3D;&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot;&#x2F;&gt;
 
    &lt;!-- 提供了入门的方式，在内存中存入用户名和密码
    &lt;security:authentication-manager&gt;
    	&lt;security:authentication-provider&gt;
    		&lt;security:user-service&gt;
    			&lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;&#123;noop&#125;admin&quot; authorities&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;
    		&lt;&#x2F;security:user-service&gt;
    	&lt;&#x2F;security:authentication-provider&gt;
    &lt;&#x2F;security:authentication-manager&gt;
    --&gt;
    &lt;security:global-method-security secured-annotations&#x3D;&quot;enabled&quot;&#x2F;&gt;
&lt;&#x2F;beans&gt;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<pre class="line-numbers language-none"><code class="language-none">@Configuration &#x2F;&#x2F; 里面已经包含了@Component 所以不用再上下文中在引入入了
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;
&#x2F;&#x2F; spring自带的
@Autowired
private UserDetailsService userDetailsService;
&#x2F;**
* configure(HttpSecurity)方法定义了哪些URL路径应该被保护
*&#x2F;
@Override
 
 
protected void configure(HttpSecurity http) throws Exception &#123;
 
       
 
http.authorizeRequests()&#x2F;&#x2F; 该方法所返回的对象的方法来配置请求级别的安全细节
.antMatchers(&quot;&#x2F;login&quot;).permitAll() &#x2F;&#x2F; 登录页面不拦截
.antMatchers(&quot;&#x2F;api&#x2F;**&quot;).permitAll() &#x2F;&#x2F; 调用api不需要拦截
.antMatchers(HttpMethod.POST, &quot;&#x2F;checkLogin&quot;).permitAll().anyRequest().authenticated()&#x2F;&#x2F; 对于登录路径不进行拦截
.and().formLogin()&#x2F;&#x2F; 配置登录页面
.loginPage(&quot;&#x2F;login&quot;)&#x2F;&#x2F; 登录页面的访问路径;
.loginProcessingUrl(&quot;&#x2F;checkLogin&quot;)&#x2F;&#x2F; 登录页面下表单提交的路径
.failureUrl(&quot;&#x2F;login?paramserror&#x3D;true&quot;)&#x2F;&#x2F; 登录失败后跳转的路径,为了给客户端提示
.defaultSuccessUrl(&quot;&#x2F;index&quot;)&#x2F;&#x2F; 登录成功后默认跳转的路径;
.and().logout()&#x2F;&#x2F; 用户退出操作
.logoutRequestMatcher(new AntPathRequestMatcher(&quot;&#x2F;logout&quot;, &quot;POST&quot;))&#x2F;&#x2F; 用户退出所访问的路径，需要使用Post方式
.permitAll().logoutSuccessUrl(&quot;&#x2F;login?logout&#x3D;true&quot;)&#x2F;&#x2F;&#x2F; 退出成功所访问的路径
.and().exceptionHandling().accessDeniedPage(&quot;&#x2F;403&quot;)
.and()
.csrf().disable()
.headers().frameOptions()&#x2F;&#x2F; 允许iframe内呈现。
.sameOrigin()
.and().sessionManagement()
&#x2F;*如果用户在不退出登录的情况下使用用户名进行身份验证，并试图对“用户”进行身份验证，
* 那么第一个会话将被强制终止并发送到&#x2F;login?expired页面。
*&#x2F;
  .maximumSessions(1)
  &#x2F;&#x2F;.expiredUrl(&quot;&#x2F;login?expired&#x3D;true&quot;)&#x2F;&#x2F;如果是异步请求。无法进行页面跳转;
    &#x2F;&#x2F;session过期处理策略
 
   .expiredSessionStrategy(new SessionInformationExpiredStrategy() &#123;

@Override
public void onExpiredSessionDetected(SessionInformationExpiredEvent event) throws IOException, ServletException &#123;
  String header &#x3D; event.getRequest().getHeader(&quot;X-Requested-With&quot;);
  System.out.println(&quot;header:&quot;+header);
 if(header!&#x3D;null&amp;&amp;header.equals(&quot;XMLHttpRequest&quot;))&#123;&#x2F;&#x2F;异步请求
    JSONObject object&#x3D; new JSONObject();
    object.put(&quot;resultCode&quot;, 302);
    object.put(&quot;redirectUrl&quot;, &quot;login?expired&#x3D;true&quot;);
   &#x2F;&#x2F;返回严格的json数据
   event.getResponse().getWriter().write(object.toJSONString());
&#125;else&#123;
   event.getResponse().sendRedirect(&quot;&#x2F;myweb&#x2F;login?expired&#x3D;true&quot;); 
&#125; 
 
&#125;
&#125;);
 
&#125;
 
       &#x2F;**
* 忽略静态资源
*&#x2F;
 
 
@Override
public void configure(WebSecurity web) throws Exception &#123;
&#x2F;*
* 在springboot中忽略静态文件路径，直接写静态文件的文件夹 springboot默认有静态文件的放置路径，如果应用spring
* security，配置忽略路径 不应该从springboot默认的静态文件开始
* 如：在本项目中，所有的js和css都放在static下，如果配置忽略路径，则不能以static开始
* 配置成web.ignoring().antMatchers(&quot;&#x2F;static&#x2F;*&quot;);这样是不起作用的
*&#x2F;
 
web.ignoring().antMatchers(&quot;&#x2F;themes&#x2F;**&quot;, &quot;&#x2F;script&#x2F;**&quot;);
 
&#125;
 
        &#x2F;**
* 配置自定义用户服务
*&#x2F;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
auth.userDetailsService(userDetailsService);
&#x2F;&#x2F; .passwordEncoder(passwordEncoder());
 
&#125;
 
&#x2F;**
* 密码加密
*&#x2F;
&#x2F;*
* @Bean public BCryptPasswordEncoder passwordEncoder() &#123; return new
* BCryptPasswordEncoder(); &#125;
*&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/f/about" rel="external nofollow noreferrer">摩托</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://fengylf.github.io/f/f/2021/08/25/note/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/security%20xml%E9%85%8D%E7%BD%AE%E6%96%87%E7%AB%A0/">https://fengylf.github.io/f/f/2021/08/25/note/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/security%20xml%E9%85%8D%E7%BD%AE%E6%96%87%E7%AB%A0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/f/about" target="_blank">摩托</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/f/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/f/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/f/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/f/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/f/2021/08/25/note/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E8%B7%AF%E5%BE%84%E7%9B%B8%E5%85%B3/">
                    <div class="card-image">
                        
                        
                        <img src="/f/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            摩托
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/f/2021/08/25/note/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/">
                    <div class="card-image">
                        
                        
                        <img src="/f/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            摩托
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/f/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/f/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/f/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/f/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/f/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/f/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/f/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/f/about" target="_blank">摩托</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">329.5k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1300379737@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1300379737" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1300379737" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/f/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/f/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/f/libs/materialize/materialize.min.js"></script>
    <script src="/f/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/f/libs/aos/aos.js"></script>
    <script src="/f/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/f/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/f/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/f/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/f/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/f/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
